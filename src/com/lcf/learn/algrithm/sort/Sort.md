# 排序算法
## 问题描述

## O(log(n)) 算法

### 快速排序
#### 算法流程
假设要排序的数组如下：
`[0, 3, 7, 8, 7, 1, 5, 4, 5, 6, 2, 4, 9, 0]`

快速排序的思想是每次将数组划分成左、中、右两个部分，左右各是一个数组，中是一个数左侧元素均小于等于中值，右侧
元素均大于指定值，对左侧和右侧递归进行这个过程；对于给定数组的计算过程如下：

第一趟划分：

`[0, 3, 7, 8, 7, 1, 5, 4, 5, 6, 2, 4, 9, 0]` 使用最后一个元素划分为

`[0, 3, 7, 8, 7, 1, 5, 4, 5, 6, 2, 4, 9]` 和 `0` 和 `[]`

第二趟划分：

上面的结果左侧继续划分为：
`[0, 3, 7, 8, 7, 1, 5, 4, 5, 6, 2, 4]` 和 `9`

第三趟划分

上面的结果左侧继续划分为：
`[0, 3, 1, 4, 2]` 和 `[ 7, 8, 7, 5, 5, 6]` 和 `4`

第四趟划分：

上面的结果左侧划分为：
`[0, 1]` 和 `[3, 4]` 和 `2`

右侧划分为：
`[ 5, 5]` 和 `[7, 7, 8]` 和 `6`

至此数组实际上已经完全有序了，后续还需要一次划分，这里省略掉；

**算法核心的步骤是partition，partition**

#### 复杂度分析
- 一共需要进行 log2(N) 趟；每一趟需要遍历每个子数组，每一趟所有子数组的长度之和为N，所以总的时间复杂度为N * log2(N);
- 在最坏的情况下（数组是正序或者逆序）时每次都划分出一个空数组，则每次确定了一个元素的顺序，时间复杂度退化为O(N^2)
- 空间复杂度为O(1)

#### 优化
- 可以使用尾递归的方式进行优化，减少递归调用的开销；尾递归每次调用的时候对左边进行递归，
右边迭代进行partition，这样可以使调用时只需要一次递归。

#### 相关问题

##### 求数组中第K大的元素
解题思路：进行partition，如果partition的位置大于k，则在左边进行partition，如果小于k，
则在右边进行，直到partition返回的结果等于k

### 归并排序

### 堆排序

## O(n^2) 算法

### 冒泡排序

### 选择排序

### 插入排序

## 相关问题

### 链表排序

### 逆序对

